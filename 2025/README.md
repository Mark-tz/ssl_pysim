# 移动机器人控制仿真实验
## 实验背景

想象你正在控制一个在地面上移动的机器人。这个机器人有两个基本控制参数：
- 移动速度（vx）：控制机器人前进/后退的速度
- 旋转速度（vw）：控制机器人转向的速度

机器人需要从起点(0,0)移动到目标点(10,10)，单位均为米。环境中随机分布着10-20个圆形障碍物，每个障碍物的半径为0.5米。

### 运动约束
机器人的速度和加速度受到以下限制：
1. 速度限制：
   - 移动速度：-4.0 m/s ≤ vx ≤ 4.0 m/s
   - 旋转速度：-2.0 rad/s ≤ vw ≤ 2.0 rad/s
2. 加速度限制：
   - 最大移动加速度：4.0 m/s²
   - 最大旋转加速度：4.0 rad/s²

### 速度空间离散化
机器人的任务是在一个充满障碍物的环境中，安全地移动到目标位置。机器人会自行在当前可行的速度空间内决策，为了计算速度考虑，机器人会在可行的最小速度到最大速度之间搜索7个值，旋转速度搜索5个值，共计35种速度组合。

**为了完成这个任务，我们需要为机器人设计一个"决策函数"，帮助它选择最佳的速度组合。**

## 实验任务

你的任务是完成`cost_fn.py`文件中的`cost_fn`函数。这个函数的作用是评估给定速度组合的"好坏程度"。

### 函数输入参数：
- `vel_x`: 当前考虑的移动速度
- `vel_w`: 当前考虑的旋转速度
- `obstacle_min_dist`: 机器人以`vel_x`和`vel_w`速度值移动1s的完整预测轨迹中，与障碍物的最小距离
- `goal_dist`: 机器人以`vel_x`和`vel_w`速度值移动1s后的预测位置与目标的距离

注意：输入值为机器人所有可选的35个值，你的算法需要为这35种决策进行代价评估，即函数的返回值也应该时一个长度为35的数组。
在python中，你无需使用for循环来遍历这35个速度组合，你可以直接使用numpy通过表达式直接计算结果，就像输入只是一个数值一样。
例如：

```python
import numpy as np
# 假设输入的值
# goal_dist = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
# obstacle_min_dist = np.array([0.1, 0.2, 0.3, 0.4, 0.5])
cost = np.abs(goal_dist) * 0.5 - np.abs(obstacle_min_dist)
# cost = np.array([0.4, 0.8, 1.2, 1.6, 2.0])
```


### 函数输出：
- 一个数值，表示当前速度组合的"代价"。代价越小，表示这个速度组合越好。

### 设计思路：
1. 当机器人离障碍物越近，代价应该越大
2. 当机器人离目标越远，代价应该越大
3. 你可以通过调整这两个因素的权重来优化机器人的行为

### 其他参数：

* SEED: 随机种子，用于控制随机数生成器的行为
* SIM_PAUSE_TIME: 单帧画面的暂停时间，单位为秒
   * 设置为0.01，可以环境加快运行速度
   * 设置为-1，可以手动控制画面的暂停，按空格键继续

## 测试方法

1. 运行`main.py`文件，观察机器人行为：
   ```bash
   python main.py
   ```
2. 仿真窗口会显示：
   - 左侧：机器人运动轨迹和障碍物
   - 中间：不同速度组合的代价分布
   - 右侧：机器人速度随时间变化曲线


## 常用函数参考

### np.clip
限制数值在指定范围内

示例：
```python
import numpy as np
x = np.clip([10, -2, 3], 0, 5)  # x = [5, 0, 3]
```

### np.hypot
计算直角三角形的斜边长度

示例：
```python
import numpy as np
dist = np.hypot(3, 4)  # dist = 5.0
```

### 数学运算
- 加法：`a + b`
- 乘法：`a * b`
- 除法：`a / b`
- 倒数：`1.0 / a`

## 评分标准

为了确保公平性，评测将使用固定随机种子(SEED)运行十次，每次最长模拟时间为20秒。单次运行会在以下三种情况下结束：
1. 到达目标点：机器人与目标点距离小于`0.2m`，且机器人vx速度小于`0.2m/s`
2. 与障碍物发生碰撞：机器人与某障碍物中心点距离小于0.5m
3. 超时：模拟时间达到20秒

评测标准如下：
1. 成功到达目标点次数
2. 失败次数中，未碰撞障碍物次数
3. 成功到达的平均时长（精确到0.1s）
4. 失败尝试中，首次障碍物撞击发生时间的平均值（精确到0.1s）

排名规则：
1. 以成功到达目标点次数排名
2. 如果成功次数相同，则比较失败次数中未碰撞障碍物的次数，次数较多者排名靠前
3. 如果仍无法分出排名，则比较成功到达的平均时长，时间较短者排名靠前
4. 如果仍无法分出排名，则比较失败尝试中首次障碍物撞击发生时间的平均值，时间较久者排名靠前

## 代码要求

1. 机器人能够安全避开所有障碍物
2. 机器人能够高效到达目标位置
3. 代码简洁高效，使用合理的数学表达式

## 提交方式

* 在最终测试时，会现场随机一个`SEED`种子，保证所有测试者的测试环境一致。
* 手动修改cost_fn.py文件中的`SEED`值，然后运行。
* 在完成10次测试后，会生成一个res2025.gzip文件。
* 将这个文件重命名后提交即可，命名方式为：`学号_姓名_res2025.gzip`。

祝你好运！